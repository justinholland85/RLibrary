X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
Temp           <-  Lib.Alluvial(X, Output = 1)
Chord.Fills    <- Temp$Args$Chord.Fills
Chord.Bords    <- Temp$Args$Chord.Bords
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,]   <-  Chord.Fills[i,]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,]   <-  Chord.Bords[i,]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
for( i in 1:(N.Grp - 1)){
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Count[i,]
X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,]   <-  Chord.Fills[i,]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,]   <-  Chord.Bords[i,]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
N.Grp
Count
Dist
for( i in 1:(N.Grp - 2)){
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Count[i,]
X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,]   <-  Chord.Fills[i,]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,]   <-  Chord.Bords[i,]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
Lib.MultiAlluvial(List.X, Chord.Fills.Force = Chord.Fills.Force, Chord.Bords.Force = Chord.Bords.Force )
List.X
List.X
Count
List.X             <-  list()
Chord.Fills.Force  <-  list()
Chord.Bords.Force  <-  list()
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Count[1,]
X[1,]   <-  Lib.NA.To.Zero(Dist[1,])
Temp           <-  Lib.Alluvial(X, Output = 1)
List.X             <-  list()
Chord.Fills.Force  <-  list()
Chord.Bords.Force  <-  list()
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Count[1,]
X[1,]   <-  Lib.NA.To.Zero(Dist[1,])
Temp           <-  Lib.Alluvial(X, Output = 1)
for( i in 1:(N.Grp - 2)){
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Lib.NA.To.Zero(Count[i,])
X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,]   <-  Chord.Fills[i,]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,]   <-  Chord.Bords[i,]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
Lib.MultiAlluvial(List.X, Chord.Fills.Force = Chord.Fills.Force, Chord.Bords.Force = Chord.Bords.Force )
i.Chord.Fills
i.Chord.Fills
for( i in 1:(N.Grp - 2)){
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Lib.NA.To.Zero(Count[i,])
X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,(i+1):Chord.Bords.Force]   <-  Chord.Fills[i,(i+1):Chord.Bords.Force]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,(i+1):Chord.Bords.Force]   <-  Chord.Bords[i,(i+1):Chord.Bords.Force]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
for( i in 1:(N.Grp - 2)){
X       <-  array(dim=c(N.Grp,N.Grp), 0)
diag(X) <-  Lib.NA.To.Zero(Count[i,])
X[i,]   <-  Lib.NA.To.Zero(Dist[i,])
i.Chord.Fills  <-  array(dim = dim(Chord.Fills), "transparent")
i.Chord.Fills[i,(i+1):N.Grp]   <-  Chord.Fills[i,(i+1):N.Grp]
i.Chord.Bords  <-  array(dim = dim(Chord.Bords), "transparent")
i.Chord.Bords[i,(i+1):N.Grp]   <-  Chord.Bords[i,(i+1):N.Grp]
List.X[[i]]             <-  X
Chord.Fills.Force[[i]]  <-  i.Chord.Fills
Chord.Bords.Force[[i]]  <-  i.Chord.Bords
}
Lib.MultiAlluvial(List.X, Chord.Fills.Force = Chord.Fills.Force, Chord.Bords.Force = Chord.Bords.Force )
pdf("EdenMonaro.pdf", with = 11.7, height = 8.3)
pdf("EdenMonaro.pdf", width = 11.7, height = 8.3)
Lib.MultiAlluvial(List.X, Chord.Fills.Force = Chord.Fills.Force, Chord.Bords.Force = Chord.Bords.Force )
dev.off()
source("C:/Users/justi/Documents/GitHub/RLibrary/Start.R")
Dir.Main    <-  "E:/Backup/SlikeAB"
Dir.ZZ      <-  paste0(Dir.Main,"/ZZ" )
setwd(Dir.Main)
Dirs.Main   <-  list.dirs(recursive = FALSE)
Main        <-  setdiff(Dirs.Main, grep(Dirs.Main, pattern = "ZZ", value = TRUE))
setwd(Dir.ZZ)
Dirs.ZZ     <-  list.dirs(recursive = FALSE)
ZZ          <-  setdiff(Dirs.ZZ, grep(Dirs.ZZ, pattern = "ZZ", value = TRUE))
Long.Main    <-  paste0(Dir.Main, "/", gsub(Main, pattern = "./", replacement = ""))
Long.ZZ      <-  paste0(Dir.ZZ, "/", gsub(ZZ, pattern = "./", replacement = ""))
Long.Full    <-  c(Long.Main, Long.ZZ)
N            <-  length(Long.Full)
X     <-  list()
for(i in 1:N){
V      <-  numeric(0)
setwd(Long.Full[i])
Files    <-   list.files()
V[[1]]   <-  length(setdiff(Files, c("A", "B", "C", "D", "E")))
for(k in c("A", "B", "C", "D", "E")){
if(k %in% Files){
setwd(paste0(Long.Full[i], "/", k))
k.Files   <-  list.files()
N.k       <- length(k.Files)
if("X" %in% k.Files){
N.k  <-  N.k - 1
setwd(paste0(Long.Full[i], "/", k,"/X"))
X.Files   <-  list.files()
N.X       <-  length(X.Files)
} else {N.X <- 0}
V[[ 1 + match(k, c("A", "B", "C", "D", "E"))]]  <-  N.k + N.X
} else { V[[ 1 + match(k, c("A", "B", "C", "D", "E"))]] <- 0}
}
X[[i]]   <-  V
}
Weights    <-  c(5, seq(5,1)^2)
W   <-  do.call(rbind, lapply(X,  '*', Weights) )
X   <-  do.call(rbind, X)
Text    <-  array(dim = dim(X), rep(gsub(Long.Full, pattern = Dir.Main, replacement = ""), 5))
Text    <-  paste0(Text,"/",  rep(c("0", "A", "B", "C", "D", "E"), rep(nrow(Text), 6)))
Text    <-  array(dim = dim(X), Text)
Dummy      <-  t(array(dim = rev(dim(X )) ,c(0, seq(4,0))))
DummyCount <-  t(array(dim = rev(dim(X )) ,c(0, rep(1,5))))
Average   <-    rowSums(X *  Dummy) / pmax(rowSums(4 * X * DummyCount), 1)
Invert    <-    1 - Average
Log2      <-  log(Invert, 2)
Mult      <-  1 + abs(Log2)
W.Tot   <-  sum(W)
W.Cum   <-  cumsum(c(W))
R       <-  ceiling(W.Tot * runif(1))
c(Text)[which(c(W.Cum) >= R)[[1]] ]
c(W)[which(c(W.Cum) >= R)[[1]]]
c(X)[which(c(W.Cum) >= R)[[1]]]
source("C:/Users/justi/Documents/GitHub/RLibrary/Start.R")
Lib.LayeredHier()
List.X
X   <-  c("A", "B", "C")
Test   <-  expand.grid(X, X)
Test
Lib.LayeredHier(Test, Values = ceiling(10 * runif(nrow(Test))) )
ceiling(10 * runif(nrow(Test)))
Lib.LayeredHier
Test
class(Test)
lapply(Test, class)
Test   <-  expand.grid(X, X, stringsAsFactors = FALSE)
Lib.LayeredHier(Test, Values = ceiling(10 * runif(nrow(Test))) )
Values <-  ceiling(10 * runif(nrow(Test)))
Values
Lib.LayeredHier(Test,  Values)
X   <-  c("A", "B", "C")
Test   <-  expand.grid(X, X, X,  stringsAsFactors = FALSE)
Values <-  ceiling(10 * runif(nrow(Test)))
Lib.LayeredHier(Test,  Values)
Cats   <-  expand.grid(X, X, X,  stringsAsFactors = FALSE)
Values <-  ceiling(10 * runif(nrow(Test)))
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
BG	<-	"gray21"
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Test)))
Lib.LayeredHier(Test,  Values)
class(Cats)
Cats
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
FlipAx  <-  0
Main  <-  ""
Plot.New  <-  1
Xmin  <-  0
Xmax  <-  1
Ymin  <-  0
Ymax  <-  1
Text.FirstOnly  <-  1
N  <-  ncol(Cats)
Ypoints  <-  seq(0,1,1/N)
Eps.Text  <-  .1 * 1/N
BG0  <-  par()$bg
par(bg=BG)
Divide  <- 1000
ID   <-  seq(1,nrow(Cats))
# open plot window
if(Plot.New==1){
plot(c(0,1), c(0,1), type='n', xaxt='n', yaxt='n', xlab="", ylab="", bty='n', main = Main)
}
# Create shells for plot data
Plot.Xpoints  	<-  list()
Plot.Colours  	<-  list()
Plot.BorderCol  	<-  list()
Plot.Text  		<-  list()
# Initialise at base level
Tapply  		<-  tapply(Values,as.character(Cats[,1]),sum)
Group 		<-  match(as.character(Cats[,1]), names(Tapply))
Group.Order 	<-  match(as.character(Cats[,1]),as.character(Ref))
Group.String	<-  as.character(Cats[,1])
Tapply.Order	<-  order(Group.Order[match(names(Tapply),Group.String)])
Tapply		<-  Tapply[Tapply.Order]
Proportions  	<-  Tapply / sum(Tapply)
X  			<-  cumsum(Proportions)
Plot.Xpoints[[1]] <-  c(0,X)
Match.Colour 	 	<-  match(names(Tapply), as.character(Ref))
Plot.Colours[[1]]  	<-  Colours[Match.Colour]
Plot.BorderCol[[1]]	<-  BorderCols[Match.Colour]
Plot.Text[[1]]		<-  Ref[Match.Colour]
for(i in 2:N){
SubGroup.String   <-  paste(Group , Cats[,i], sep="$")
Tapply  		<-  tapply(Values, SubGroup.String, sum)
SubGroup.Ord      <-  match(as.character(Cats[,i]),as.character(Ref))
Group.Ord.Score   <-  Group.Order + SubGroup.Ord  / Divide
Sort			<-  sort(Group.Ord.Score)
Group.Order		<-  match(Group.Ord.Score,Sort)
Tapply.Order	<-  order(Group.Ord.Score[match(names(Tapply),SubGroup.String)])
Tapply  		<-  Tapply[Tapply.Order]
###
Proportions  	<-  Tapply / sum(Tapply)
X  			<-  cumsum(Proportions)
Plot.Xpoints[[i]] <-  c(0,X)
Group  		<-  match(SubGroup.String , names(Tapply))
Colours.Dummy  	<-  Colours[match(as.character(Cats[,i]),  as.character(Ref))]
BorderCols.Dummy  <-  BorderCols[match(as.character(Cats[,i]),  as.character(Ref))]
Match.Colour  		<-  match(names(Tapply), SubGroup.String)
Plot.Colours[[i]]  	<-  Colours.Dummy[Match.Colour]
Plot.BorderCol[[i]]  	<-  BorderCols.Dummy[Match.Colour]
Plot.Text[[i]]		<-  Cats[Match.Colour,i]
}
for(i in 1:N){
Temp.Xpoints  	<-  Plot.Xpoints[[i]]
Temp.Colours  	<-  Plot.Colours[[i]]
Temp.BorderCol  	<-  Plot.BorderCol[[i]]
Temp.Text 		<-  Plot.Text[[i]]
M  			<-  length(Temp.Colours)
for(j in 1:M){
X0  		<-  Temp.Xpoints[j]
X1  		<-  Temp.Xpoints[j+1] - Eps
Y0  		<-  Ypoints[i]
Y1  		<-  Ypoints[i+1] - Eps
X.Share  	<-  X1 - X0
# re-map X and Y into plot reduced plot window
X0      <-  Xmin + X0 * (Xmax - Xmin)
X1      <-  Xmin + X1 * (Xmax - Xmin)
Y0      <-  Ymin + Y0 * (Ymax - Ymin)
Y1      <-  Ymin + Y1 * (Ymax - Ymin)
Text.X 	<-  (X0 + X1) / 2
Text.Y	<-  Y0 + Eps.Text
Col  		<-  Temp.Colours[j]
Border  	<-  Temp.BorderCol[j]
Text		<-  Temp.Text[j]
Plot.Text.Cex 	<-  Text.Cex[i]
if(X.Share > Min.Plot){
if(FlipAx == 0){
polygon(c(X0,X0,X1,X1),c(Y0,Y1,Y1,Y0),col=Col,border=Col)
} else {
polygon(c(Y0,Y1,Y1,Y0),c(X0,X0,X1,X1),col=Col,border=Col)
}
}
if(Text.FirstOnly == 0 | i == 1){
if(X.Share > Min.Text){
if(FlipAx ==0){
text(Text.X, Text.Y, labels=Text, col= Border, cex = Plot.Text.Cex)
} else {
text(Text.Y, Text.X, labels=Text, col= Border, cex = Plot.Text.Cex)
}}}
}}
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
FlipAx  <-  0
Main  <-  ""
Plot.New  <-  1
Xmin  <-  0
Xmax  <-  1
Ymin  <-  0
Ymax  <-  1
Text.FirstOnly  <-  1
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Test)))
Lib.LayeredHier(Test,  Values)
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
FlipAx  <-  0
Main  <-  ""
Plot.New  <-  1
Xmin  <-  0
Xmax  <-  1
Ymin  <-  0
Ymax  <-  1
Text.FirstOnly  <-  1
N  <-  ncol(Cats)
Ypoints  <-  seq(0,1,1/N)
Eps.Text  <-  .1 * 1/N
rm(;list = ls())
X   <-  c("A", "B", "C")
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Test)))
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
FlipAx  <-  0
Main  <-  ""
Plot.New  <-  1
Xmin  <-  0
Xmax  <-  1
Ymin  <-  0
Ymax  <-  1
Text.FirstOnly  <-  1
N  <-  ncol(Cats)
Ypoints  <-  seq(0,1,1/N)
Eps.Text  <-  .1 * 1/N
if(missing(Eps)){Eps  <-  0}
if(missing(Min.Plot)){Min.Plot <-  0.001}
if(missing(Min.Text)){Min.Text <-  0.005}
if(missing(Text.Cex)){Text.Cex <-  1}
if(length(Text.Cex) < N + 1){Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))}
if(missing(BG)){BG	<-	"gray21"}
if(missing(Ref)){Ref  <-  sort(unique(c(Cats)))}
if(missing(Colours)){ Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,] }
if(missing(BorderCols)){ BorderCols  <-  rep("black", length(Ref)) }
if(missing(FlipAx)){ FlipAx  <-  0}
if(missing(Main)){ Main  <-  ""}
if(missing(Plot.New)){ Plot.New  <-  1}
if(missing(Xmin)){ Xmin  <-  0}
if(missing(Xmax)){ Xmax  <-  1}
if(missing(Ymin)){ Ymin  <-  0}
if(missing(Ymax)){ Ymax  <-  1}
if(missing(Text.FirstOnly)){ Text.FirstOnly  <-  1}
BG0  <-  par()$bg
par(bg=BG)
Divide  <- 1000
ID   <-  seq(1,nrow(Cats))
# open plot window
if(Plot.New==1){
plot(c(0,1), c(0,1), type='n', xaxt='n', yaxt='n', xlab="", ylab="", bty='n', main = Main)
}
# Create shells for plot data
Plot.Xpoints  	<-  list()
Plot.Colours  	<-  list()
Plot.BorderCol  	<-  list()
Plot.Text  		<-  list()
# Initialise at base level
Tapply  		<-  tapply(Values,as.character(Cats[,1]),sum)
Group 		<-  match(as.character(Cats[,1]), names(Tapply))
Group.Order 	<-  match(as.character(Cats[,1]),as.character(Ref))
Group.String	<-  as.character(Cats[,1])
Tapply.Order	<-  order(Group.Order[match(names(Tapply),Group.String)])
Tapply		<-  Tapply[Tapply.Order]
Proportions  	<-  Tapply / sum(Tapply)
X  			<-  cumsum(Proportions)
Plot.Xpoints[[1]] <-  c(0,X)
Match.Colour 	 	<-  match(names(Tapply), as.character(Ref))
Plot.Colours[[1]]  	<-  Colours[Match.Colour]
Plot.BorderCol[[1]]	<-  BorderCols[Match.Colour]
Plot.Text[[1]]		<-  Ref[Match.Colour]
######
# Loop over higher levels
for(i in 2:N){
SubGroup.String   <-  paste(Group , Cats[,i], sep="$")
Tapply  		<-  tapply(Values, SubGroup.String, sum)
SubGroup.Ord      <-  match(as.character(Cats[,i]),as.character(Ref))
Group.Ord.Score   <-  Group.Order + SubGroup.Ord  / Divide
Sort			<-  sort(Group.Ord.Score)
Group.Order		<-  match(Group.Ord.Score,Sort)
Tapply.Order	<-  order(Group.Ord.Score[match(names(Tapply),SubGroup.String)])
Tapply  		<-  Tapply[Tapply.Order]
###
Proportions  	<-  Tapply / sum(Tapply)
X  			<-  cumsum(Proportions)
Plot.Xpoints[[i]] <-  c(0,X)
Group  		<-  match(SubGroup.String , names(Tapply))
Colours.Dummy  	<-  Colours[match(as.character(Cats[,i]),  as.character(Ref))]
BorderCols.Dummy  <-  BorderCols[match(as.character(Cats[,i]),  as.character(Ref))]
Match.Colour  		<-  match(names(Tapply), SubGroup.String)
Plot.Colours[[i]]  	<-  Colours.Dummy[Match.Colour]
Plot.BorderCol[[i]]  	<-  BorderCols.Dummy[Match.Colour]
Plot.Text[[i]]		<-  Cats[Match.Colour,i]
}
######
# Plot the boxes
for(i in 1:N){
Temp.Xpoints  	<-  Plot.Xpoints[[i]]
Temp.Colours  	<-  Plot.Colours[[i]]
Temp.BorderCol  	<-  Plot.BorderCol[[i]]
Temp.Text 		<-  Plot.Text[[i]]
M  			<-  length(Temp.Colours)
for(j in 1:M){
X0  		<-  Temp.Xpoints[j]
X1  		<-  Temp.Xpoints[j+1] - Eps
Y0  		<-  Ypoints[i]
Y1  		<-  Ypoints[i+1] - Eps
X.Share  	<-  X1 - X0
# re-map X and Y into plot reduced plot window
X0      <-  Xmin + X0 * (Xmax - Xmin)
X1      <-  Xmin + X1 * (Xmax - Xmin)
Y0      <-  Ymin + Y0 * (Ymax - Ymin)
Y1      <-  Ymin + Y1 * (Ymax - Ymin)
Text.X 	<-  (X0 + X1) / 2
Text.Y	<-  Y0 + Eps.Text
Col  		<-  Temp.Colours[j]
Border  	<-  Temp.BorderCol[j]
Text		<-  Temp.Text[j]
Plot.Text.Cex 	<-  Text.Cex[i]
if(X.Share > Min.Plot){
if(FlipAx == 0){
polygon(c(X0,X0,X1,X1),c(Y0,Y1,Y1,Y0),col=Col,border=Col)
} else {
polygon(c(Y0,Y1,Y1,Y0),c(X0,X0,X1,X1),col=Col,border=Col)
}
}
if(Text.FirstOnly == 0 | i == 1){
if(X.Share > Min.Text){
if(FlipAx ==0){
text(Text.X, Text.Y, labels=Text, col= Border, cex = Plot.Text.Cex)
} else {
text(Text.Y, Text.X, labels=Text, col= Border, cex = Plot.Text.Cex)
}}}
}}
rm(list = ls())
source("C:/Users/justi/Documents/GitHub/RLibrary/Start.R")
X   <-  c("A", "B", "C")
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Test)))
X   <-  c("A", "B", "C")
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Cats)))
Eps  <-  0
Min.Plot <-  0.001
Min.Text <-  0.005
Text.Cex <-  1
Text.Cex  <-  c(Text.Cex,rep(Text.Cex[length(Text.Cex)],N + 2 - length(Text.Cex)))
BG	<-	"gray21"
Ref  <-  sort(unique(c(Cats)))
Colours  <-  Lib.ColourScheme(length(Ref),4, V=1, Plot = 0)[3,]
BorderCols  <-  rep("black", length(Ref))
FlipAx  <-  0
Main  <-  ""
Plot.New  <-  1
Xmin  <-  0
Xmax  <-  1
Ymin  <-  0
Ymax  <-  1
Text.FirstOnly  <-  1
Lib.LayeredHier(Test,  Values)
Lib.LayeredHier(Cats,  Values)
X   <-  c("A", "B", "C")
Cats   <-  as.matrix(expand.grid(X, X, X,  stringsAsFactors = FALSE))
Values <-  ceiling(10 * runif(nrow(Cats)))
Lib.LayeredHier(Cats,  Values)
X
